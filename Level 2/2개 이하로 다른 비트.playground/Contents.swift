/**
 난이도: Level 2 - 월간 코드 챌린지 시즌2
 
 [문제 설명]
 양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

 x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
 예를 들어,

 f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.
 수    비트    다른 비트의 개수
 2    000...0010
 3    000...0011    1
 
 f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
 수    비트    다른 비트의 개수
 7    000...0111
 8    000...1000    4
 9    000...1001    3
 10    000...1010    3
 11    000...1011    2
 
 정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

 [제한사항]
 1 ≤ numbers의 길이 ≤ 100,000
 0 ≤ numbers의 모든 수 ≤ 1015
 
 [입출력 예]
 numbers       result
 [2,7]          [3,11]
 */

import Foundation

/**
 *  AND      :   &
 *  OR        :   |
 *  NOT      :   ~
 *  2의보수  :   -
 *  XOR      :  ^
 *  shift(R)  :  >>
 *  shift(L)  :  <<
 *  ########################################>>
 *
 *  가장 최하위에 있는 0과 바로 오른쪽에 있는 1과 교체해주면 된다. ex => [(1101) -> (1110)],  [(0111) -> (1011)],  [(1011) -> (1101)]
 *  1. 최하위 비트 구하는 공식 ( ~A) & (A+1)  => "LastBit"
 *  2. "LastBit" OR A      =>  "a"
 *  3. ~("LastBit" >> 1 )  =>  "b"
 *  answer =  "a" & "b"
 *
 *  하나씩 증가하면서 찾는것 보다 공식을 사용하면 속도가 굉장히 빠름.
 *  비트는 꾸준히 봐야 익숙해 질 것 같다..
 */
func solution(_ numbers:[Int64]) -> [Int64] {
    return numbers.map {
        let last = (~$0) & ($0+1)
        return ($0 | last) & ~(last>>1)
    }
}

print(solution([2,7,25,21]))
