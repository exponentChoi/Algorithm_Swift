//
//  1, 2, 3 더하기 5.swift
//  Dynamic Programming
//
//  Created by 최지수 on 2021/11/07.
//

/**
 [문제]
 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

 1+2+1
 1+3
 3+1
 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

 [입력]
 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

 [출력]
 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

 [예제 입력 1]
 3
 4
 7
 10
 [예제 출력 1]
 3
 9
 27
 */

/**
 (1로 끝나는 개수, 2로 끝나는 개수, 3으로 끝나는 개수)를 배열로 생성하여 연속되지 않도록 한다. (1부터 3까지는 직접 구한다.)
 
 - n = 4 일 때
 dp[1] + 3을 하면 4가 나온다. 그런데 중복되면 안되기 떄문에 끝자리가 3이 아닌 경우인 것만 구한다.
 dp[1][0]과 dp[1][1]는 1 또는 2로 끝나는 경우의 수다.
 dp[2][0]과 dp[2][2]는 2를 더했을 때 4가 되는 경우이며, 1 또는 3으로 끝나는 경우의 수다.
 dp[3][1]과 dp[3][2]는 1을 더했을 때 4가 되는 경우이며, 2 또는 3으로 끝나는 경우의 수다.

 즉 아래와 같은 식이 생성된다.
 
 */
import Foundation

/// 1, 2, 3 더하기 5 [15990번]
func _123더하기5() {
    let n = Int(readLine()!)!
    let mod = 1_000_000_009
    
    // dp = [[1로 끝나는 개수, 2로 끝나는 개수, 3으로 끝나는 개수]]
    var dp = Array(repeating: [0, 0, 0], count: 100_000 + 1)
    dp[1] = [1, 0, 0]
    dp[2] = [0, 1, 0]
    dp[3] = [1, 1, 1]
    
    for i in stride(from: 4, through: dp.count - 1, by: 1) {
        // i - 1 => 1을 더해서 만들 수 있는 경우의 수를 더한다. (1번째와, 2번째의 index의 개수를 더한다.)
        dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % mod
        
        // i - 2 => 2를 더해서 만들 수 있는 경우의 수를 더한다. (0번째와, 2번째의 index의 개수를 더한다.)
        dp[i][1] = (dp[i - 2][0] + dp[i - 2][2]) % mod
        
        // i - 3 => 3을 더해서 만들 수 있는 경우의 수를 더한다. (0번째와, 1번째의 index의 개수를 더한다.)
        dp[i][2] = (dp[i - 3][0] + dp[i - 3][1]) % mod
    }
    
    for _ in 0..<n {
        let i = Int(readLine()!)!
        print(dp[i].reduce(0, +) % mod) // dp[i]에 있는 경우의 수를 전부 더한다.
    }
}

